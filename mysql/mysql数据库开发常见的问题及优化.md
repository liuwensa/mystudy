# mysql 数据库开发常见问题及优化

## 一、库表设计

### 1.1 引擎选择

`mysql`常用的存储引擎包括`MYISAM`、`Innodb`和`Memory`，其中各自的特点如下：

- `MYISAM`：全表锁，拥有较高的执行速度，一个写请求请阻塞另外相同表格的所有读写请求，并发性能差，占用空间相对较小，`mysql 5.5`及以下仅`MYISAM`支持全文索引，不支持事务。

- `Innodb`：行级锁（`SQL`都走索引查询），并发能力相对强，占用空间是`MYISAM`的2.5倍，不支持全文索引（`mysql5.6`开始支持），支持事务。

- `Memory`：全表锁，存储在内存当中，速度快，但会占用和数据量成正比的内存空间且数据在`mysql`重启时会丢失。

基于以上特性，建议绝大部份都设置为`innodb`引擎，特殊的业务再考虑选用`MYISAM`或`Memory`，如全文索引支持或极高的执行效率等。

### 1.2 分表方法

在数据库表使用过程中，为了减小数据库服务器的负担、缩短查询时间，常常会考虑做分表设计。分表分两种，一种是纵向分表（将本来可以在同一个表的内容，人为划分存储在为多个不同结构的表）和横向分表（把大的表结构，横向切割为同样结构的不同表）。

纵向分表常见的方式有根据活跃度分表、根据重要性分表等。其主要解决问题如下：

- 表与表之间资源争用问题；
- 锁争用机率小；
- 实现核心与非核心的分级存储，如UDB登陆库拆分成一级二级三级库；
- 解决了数据库同步压力问题。

横向分表是指根据某些特定的规则来划分大数据量表，如根据时间分表。其主要解决问题如下：

- 单表过大造成的性能问题；
- 单表过大造成的单服务器空间问题。

### 1.3 索引问题

索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于更快地获取信息。 `mysql`有四种不同的索引类型：

1. 主键索此 (`PRIMARY`)
2. 唯一索引 (`UNIQUE`)
3. 普通索引 (`INDEX`)
4. 全文索引（`FULLTEXT`, `MYISAM`及`mysql 5.6`以上的`Innodb`）

建立索引的目的是加快对表中记录的查找或排序，索引也并非越多越好，因为创建索引是要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间维护索引。

在设计表或索引时，常出现以下几个问题：

- 少建索引或不建索引。
- 索引滥用。滥用索引将导致写请求变慢，拖慢整体数据库的响应速度。
- 从不考虑联合索引。实际上联合索引的效率往往要比单列索引的效率更高。
- 非最优列选择。低选择性的字段不适合建单列索引，如只有0、1标识的状态字段。

## 二、慢 SQL 问题

### 2.1 导致慢 SQL 的原因

在遇到慢`SQL`情况时，不能简单的把原因归结为`SQL`编写问题(虽然这是最常见的因素)，实际上导致慢`SQL`有很多因素，甚至包括硬件和 `mysql`本身的`bug`。根据出现的概率从大到小，罗列如下：

- `SQL`编写问题
- 锁
- 业务实例相互干绕对`IO/CPU`资源争用
- 服务器硬件
- `MYSQL BUG`

### 2.2 由`SQL`编写导致的慢`SQL`优化

针对`SQL`编写导致的慢，优化起来还是相对比较方便的。正如上一节提到的正确的使用索引能加快查询速度，那么我们在编写`SQL`语句的时候就需要注意与索引相关的规则：

- 字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；
- `mysql`不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；
- 不要在字段前面加减运算；
- 字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；
- `like`语句`%`在前面用不到索引；
- 根据联合索引的第二个及以后的字段单独查询用不到索引；
- 不要使用`select *`；
- 排序请尽量使用升序 ;
- `or`的查询尽量用`union`代替（`Innodb`）；
- 复合索引高选择性的字段排在前面；
- `order by/group by`字段包括在索引当中减少排序，效率会更高。

除了上述索引使用规则外，`SQL`编写时还需要特别注意一下几点：

- 尽量规避大事务的`SQL`，大事务的`SQL`会影响数据库的并发性能及主从同步；
- 分页语句`limit`的问题；
- 删除表所有记录请用`truncate`，不要用`delete`；
- 不让`mysql`干多余的事情，如计算；
- 输写`SQL`带字段，以防止后面表变更带来的问题，性能也是比较优的；
- 在`Innodb`上用`select count(*)`，因为`Innodb`会存储统计信息；
- 慎用`Oder by rand()`。

## 三、分析诊断工具

在日常开发工作中，我们可以做一些工作达到预防慢`SQL`问题，比如在上线前预先用诊断工具对`SQL`进行分析。常用的工具有：

```
    mysqldumpslow
    mysql profile
    mysql explain
```

## 四、优化的详细点

1. 有索引的列优先，都有索引的看查询出来的数据量，少的优先
  `WHERE`子句后面的条件顺序对大数据量表的查询会产生直接的影响，如

  ```sql
   SELECT * FROM tbl_posts WHERE t_gid = 143 AND t_is_publish = 12;
   SELECT * FROM tbl_posts WHERE t_is_publish = 12 AND t_gid = 143;
  ```
  如以上两个`SQL`语句，条件为`t_gid = 143`数据少一些，则此条件放在前边，第一天语句效率和资源cpu等占用比第二天低。

  `IS NULL, <>, !=, !>, !<, NOT, NOT EXISTS, NOT IN, NOT LIKE, LIKE '%500'`，不走索引全表扫描

2. 选择最有效率的表名顺序
`sql`解析器按照从右到左的顺序处理`FROM`子句中的表名，因此`FROM`子句中写在最后的表将被最先处理。在`FROM`子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。 

3. 注意`union`和`union all`的区别。`union`比`union all`多做了一步`distinct`操作。能用`union all`的情况下尽量不用`union`。 

4. 查询时尽量不要返回不需要的行、列。另外在多表连接查询时，尽量改成连接查询，少用子查询。 

5. 创建合理的索引，对于插入或者修改比较频繁的表，尽量慎用索引。因为如果表中存在索引，插入和修改时也会引起全表扫描。 
索引一般使用于`where`后经常用作条件的字段上。 

6. 在表中定义字段或者存储过程、函数中定义参数时，将参数的大小设置为合适即可，勿设置太大。这样开销很大。 

7. `Between`在某些时候比`IN`速度更快，`Between`能够更快地根据索引找到范围。用查询优化器可见到差别。 

  ```sql
    select * from chineseresume where title in ('男','女') 
    Select * from chineseresume where between '男' and '女' // 是一样的。由于in会在比较多次，所以有时会慢些。
  ```

8. 在必要是对全局或者局部临时表创建索引，有时能够提高速度，但不是一定会这样，因为索引也耗费大量的资源。他的创建同是实际表一样。
 
9. 尽量少用视图，它的效率低。对视图操作比直接对表操作慢,可以用存储过程来代替它。特别的是不要用视图嵌套,嵌套视图增加了寻找原始资料的难度。 
我们看视图的本质：它是存放在服务器上的被优化好了的已经产生了查询规划的`SQL`。对单个表检索数据时，不要使用指向多个表的视图， 
直接从表检索或者仅仅包含这个表的视图上读，否则增加了不必要的开销,查询受到干扰。 

10. 用`OR`的字句可以分解成多个查询，并且通过`UNION`连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用 `UNION all`执行的效率更高。多个`OR`的字句没有用到索引，改写成`UNION`的形式再试图与索引匹配。一个关键的问题是否用到索引。 
11. 没有必要时不要用`DISTINCT`和`ORDER BY`，这些动作可以改在客户端执行。它们增加了额外的开销。这同`UNION`和`UNION ALL`一样的道理。 

12. 使用`IN`时，在`IN`后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，这样可以减少判断的次数 

13. 当用`SELECT INTO`时，它会锁住系统表(`sysobjects`，`sysindexes`等等)，阻塞其他的连接的存取。创建临时表时用显示声明语句，在另一个连接中`SELECT * from sysobjects`可以看到`SELECT INTO`会锁住系统表，`Create table`也会锁系统表(不管是临时表还是系统表)。所以千万不要在事物内使用它！！！这样的话如果是经常要用的临时表请使用实表，或者临时表变量。
 
14. 一般在`GROUP BY`和`HAVING`字句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。他们的执行顺序应该如下最优：`select`的`Where`字句选择所有合适的行，`Group By`用来分组个统计行，`Having`字句用来剔除多余的分组。这样`Group By`和`Having`的开销小，查询快。对于大的数据行进行分组和`Having`十分消耗资源。如果`Group BY`的目的不包括计算，只是分组，那么用`Distinct`更快。

15. 一次更新多条记录比分多次更新每次一条快，批处理好 

16. 慎用临时表，临时表存储于`tempdb`库中，操作临时表时，会引起跨库操作。尽量用结果集和表变量来代替它。 

17. 尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过，并且被组织到一个执行规划里、且存储在数据库中的`SQL`语句，是控制流语言的集合，速度当然快。 

18. 不要在一段`SQL`或者存储过程中多次使用相同的函数或相同的查询语句，这样比较浪费资源，建议将结果放在变量里再调用，这样更快。 

19. 按照一定的次序来访问你的表。如果你先锁住表`A`，再锁住表`B`，那么在所有的存储过程中都要按照这个顺序来锁定它们。如果在某个存储过程中先锁定表`B`，再锁定表`A`，这可能就会导致一个死锁。如果锁定顺序没有被预先详细的设计好，死锁很难被发现。