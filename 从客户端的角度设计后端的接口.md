# 从客户端的角度设计后端的接口

## 前言

虽然一个api接口的业务，数据逻辑是后端提供的，但真正使用这个接口的是客户端，一个前端功能的实现流程与逻辑，客户端算是接口的需求方。所以建议在前期接口设计和评审时，客户端的应该更多的思考和参与，什么时机调什么接口？每个接口需要哪些字段？数据含义怎么给？只有这些都考虑清楚，且达成一致并产出接口文档后，当项目真正启动时，根据接口协议进行开发，才能尽量避免各种不确定因素对项目整体进度的影响。

## 接口设计规范

### 基本规范

#### 1.通用请求参数

每个请求都要携带的参数，用于描述每个请求的基本信息，后端可以通过这些字段进行接口统计，或APP终端设备的统计，可以放在请求头部header中。

```json
 const header = {
   version: 1.0.0,                             // 客户端版本version
   token: '6aab9eb8f32e566dfa41cbd48f53c80d',  // 登陆成功后，登陆令牌token
   platform:'android',	                      // android/ios
   model:'Note3',	                          // 机型信息
   appid:''	                                  // app唯一标识，服务可能提供多个app应用
 }
```

#### 2.请求路由链接

命名规范的基础上尽量保持良好的可读性，见名知意。

接口请求路由参考`restful`规范，个人理解`restful`规范是通过`path`表示当前请求的资源，通过`method`表示当前请求的行为（GET=查找,POST=增加,PUT=修改,DELETE=删除）

#### 3.响应数据

数据返回格式：

```json
  {
    code:200,       // 200：成功；非200：失败
    msg:'成功',     // 请求失败时的message
    data: {         // 数据实体
      name:'张三',
      age:20
    }
  }  
```
array类型数据：

```json
  {
    code: 200,       // 200：成功；非200：失败
    msg:'成功',     // 请求失败时的message
    data: {         // 数据实体
      list:[{
        name:'张三',
   	age:20
      }]
     }
  }  
```

判断code==200的情况下继续解析data，code!=200时，根据业务提示文案放在msg字段，客户端直接显示就可以了。

array类型的数据，即使只有1个list字段，也要保证data下是个完整的object结构，这样就可以统一将data层级下的数据当对象解析。


#### 4.命名规范

统一命名：一般采用小驼峰法，无绝对标准。

避免冗余字段：每次在新增接口字段时，注意是否已经存在同一个含义的字段，保持命名一致。

注释清晰（重要）：每个接口/字段都需要有详细的描述信息，很多时候接口体现业务逻辑，是团队中很重要的文档沉淀，同时，详细的接口文档，可以帮助新人快速熟悉业务。

#### 5.返回字段类型讨论统一

需要和两端商讨关于数据类型的返回，特别式特殊的类型，比如布尔类型等，不同语言表示方法不同

#### 6.上传/下载接口，根据md5校验数据完整性

上传，下载文件/图片时，除了file本身，还要携带该file的md5，在传输过程中可能丢失部分数据，导致文件损毁，所以需要通过md5值进行完整性校验。
上传成功后将图片url返回


#### 7.避免浮点型计算

浮点型计算可能导致精度丢失，为了避免，可以缩小单位进行存储。
例：1.5元，后端会以150分存到数据库，1.5km会存成1500m。
同理，如果一个类似距离的字段，如果是展示用，则直接返回"1.5km"，如果涉及到逻辑判断与计算（如：>1000m，执行逻辑A，>1500m，执行逻辑B），可以返回"1500，单位(m)"，至少比传1.5来的方便。当然如果要计算浮点型也是可以的，需要用到BigDecimal，这么设计只是为了减少出错的可能性。

#### 8.json数据保持良好结构

```json
  {
    userId: 1
    userName: '洒哥',
    userAvatar: 'http://xxx',
    orderId: 2,
    orderType: 1
    addressId: 5,
    addressDtl: '萝岗'
  }
```

json的3类信息user，order，address，全部堆在一起，字段多了以后，对于接口信息的读取很不直观；
客户端在定义model的时候，会将全部字段定义在一个model中，如果其他地方也有用到addressId，Name，Detail等字段信息，则需要重新定义address的model，无法实现model的复用。

```json
  {
      user:{
        id: 1
        name: '洒哥',
        avatar: 'http://xxx'
      }
      order:{
        id: 2
        type: 1
      }
      address:{
        id: 5,
        detail: '萝岗'
      }        
  }
```

优化后user，order，address字段在各自的对象内，一眼就可以看出这个接口有哪些类型的数据。还有点要注意，如果放在同一级别，id字段就需要用userId，orderId，addressId区分开，而现在根据不同结构体区分字段类型后，直接使用id就可以了。

## 瘦客户端

众所周知，客户端任何的修改都是需要发版的，特别是IOS需要走AppStore的审核流程。为了修一个bug，仅仅改几行代码，而重新走一轮发版流程，是很劳民伤财的。所以在接口设计的时候，也需要适当考虑这点，将业务重心交由后端，客户端保持逻辑简单。后端一天可以发n个版，客户端一个版本却只能发一次，有些团队一开始并没意识到这点，总觉后端就是重度业务逻辑的所在，管那么多前端的展示，字符串拼接逻辑干嘛，可是，真正到了出问题（bug或需求变更）需要发版的时候，虽然70%的锅是客户端背，但是，剩余30%也会对当初重客户端的选择而后悔，不过重点不是谁背锅，而是产品不出问题。so，为了大局，后端的RD们，我们得聊聊。
客户端尽量只负责展示逻辑，不处理业务逻辑

例如：客户端有个TextView，后端只给个status字段，status=1时，展示文案1；status=2时，展示文案2；这样设计的缺点是，如果以后要修改status=3时，展示文案1，那么这个status判断逻辑时写死在客户端，就没办法支持这种修改，且这种设计限定死了TextView只能展示2种文案。推荐方案是后端直接将TextView需要展示的文案下发，这样不管是status的判断，还是文案的展示，后期都是可变的。
客户端不处理金额的计算

例如：外卖APP，用户在下单的时候，需要选择收货地址，支付类型，优惠券等，任何一个选项的修改，都可能影响用户最后需要支付的金额。所以这里比较常见的接口设计是在每次选择完回到订单支付页面后，再发送一次请求，后端根据当前选项重新计算金额。金额永远是一款产品最重要，最敏感的信息，如果交由客户端计算，万一出错，即使少1分，都是毁灭性的，所以，关于金额，展示就好。
客户端少处理请求参数的校验与约束提示

例如：修改密码功能，密码规则"6-12字母，数字，下划线"，有3种做法：
在发送请求前，客户端校验密码规则，如果不符合，则不发送请求。优点：规则不满足时，可以减少不必要的请求。缺点：客户端写死校验逻辑，密码规则变化时，客户端需要发版。
客户端只判断null，和最短位数限制，其他校验规则交由后端处理。优点：灵活性最好。缺点：后端压力大，校验请求多。
后端在通用配置的接口返回正则表达式，客户端获取后进行正则校验。优点：具有一定灵活性。缺点：开发，调试成本较高。（推荐：即使出问题，也可以清除配置，回退到第2个方案）

## 扩展性

接口的设计要具有一定的扩展性，考虑到后续版本变化，对于接口，字段的影响及变化。
文案与图片

对于界面上的文案，图片，特别是"xxx20分钟之内"，"xxx7天到期"这些带数字的文案，不可能永远不变的，即使和PM确认了打死不变，也最好通过常量配置接口进行下发（未下发时使用APP本地默认文案，下发时使用下发的文案），我们的原则是：变与不变都能支持。
数据列表化：尽量用List(key, value)的数据格式定义类似列表的界面


list.png
方案1：客户端在写xml的时候将左侧的"姓名"，"性别"，"年龄"写死，右侧的具体数据从json解析获得

{
    "name": "张三",
    "sex": "男",
    "age": "20岁",
    "nickName": "小张"
}
方案2（推荐）：将左侧的title和右侧的value，以list(key-value)的数据形式进行下发，优点：左，右侧文案灵活配置，后期如果需要扩展，新增或删除一个条目，都可以通过后端控制。不过采用这种形式，也需要考虑实际场景，对于变化不那么频繁，数据item较少，较固定的情况下其实没有必要设计的太灵活，只会增加开发成本。

{
    "userInfos":[
    {
        "key":"姓名",
        "value":"张三"
    },{
        "key":"性别",
        "value":"男"
    },{
        "key":"年龄",
        "value":"20岁"
    },{
        "key":"昵称",
        "value":"小张"
    }]
}
3.用flag替换boolean：一般情况下，一款APP都会有config接口，用于获取一些常量文案，通用配置等信息，会有很多类似开关的字段，如："isNew"，"isVip"，"isShowBalance"等等。

{
    "isNew":"1",// 是否是新用户
    "isVip":"1",// 是否是VIP用户
    "isShowBalance":"1",//是否显示侧边栏余额模块
}
优化方案：通过二进制第1位表示"isNew"，二进制第2位表示"isVip"，二进制第3位表示"isShowBalance"。如果有其他新增状态，不需要新增字段，就需要改变返回的数据即可。

{
    "flag":"7"// 二进制：111，表示3个状态都为true
    "flag":"5"// 二进制：101，表示isNew，isShowBalance为true，isVip为false
}
long flag = 5;
System.out.println("bit=" + Long.toBinaryString(flag));
System.out.println("isNew=" + ((flag & 1) == 1));
System.out.println("isVip=" + ((flag & 2) == 2));
System.out.println("isShowBalance=" + ((flag & 4) == 4));

bit=101
isNew=true
isVip=false
isShowBalance=true

## 安全性

响应数据中包含用户隐私的字段数据，需要加*号。如：手机号，身份证，用户邮箱，支付账号，邮寄地址等。

{
 "phone":"150*****000",
 "idCard":"3500**********0555",  
 "email":"40*****00@qq.com"     
}
请求参数中包含用户隐私的字段参数，如：登陆接口的密码字段，需要进行加密传输，避免被代理捕捉请求后获取明文密码。

客户端和服务器通过约定的算法，对传递的参数值进行签名匹配，防止参数在请求过程中被抓取篡改。密钥记得放到so中，放在java层太不安全，so中要进行keystore反向签名校验，避免so被获取后直接调用获取算法。

so中要进行keystore反向签名校验


## 兼容性

APP1.0在使用接口A，如果此时在开发1.1的时候修改了接口A的逻辑，在1.1发版的时候线上就会出现2个版本的客户端访问同一个接口A，为了保证1.0客户端调用接口A不会出错，就需要通过version字段或path中的"v1/login"，"v2/login"进行区分，不同版本客户端访问同一接口时处理逻辑要各自独立。
接口/字段的删除，修改要谨慎：
对于已经存在的接口进行修改，需要考虑对线上版本的影响，尽量是数据含义，和新增字段，而不是去修改。
md5缓存的兼容性：
如果1.0的接口A存在md5缓存，正常都是后端上线后再发布1.1客户端的顺序，如果在后端上线后，1.1还没发布的情况下，此时1.0的客户端就缓存了1.1后端逻辑的md5，在更新成1.1的时候，md5没有变，就有可能缓存的还是1.0的数据，所以比较推荐后端在计算md5的时候把version加上，这样更新APP可以保证md5是不一样的。

## 性能优化

合并接口

为了减少客户端和服务器建立连接和断开连接消耗的时间，资源，电量，尽量避免频繁的间隔网络请求。业务场景允许的情况下，尽量1个页面对应1个接口。原先一个页面要通过多个请求获取多种类型数据的情况，最好能通过一个接口全部获取得到。又如：在调用B接口前需要A接口的前置数据的情况，可以让后端支持下，在调用A接口时直接返回B接口的数据，减少类似这种的连续请求。
字段精简

定义字段名时，在保证良好可读性的前提下，尽量精简，减少流量的消耗

md5缓存

对于频繁调用，且数据不常变化的接口（config配置接口），可以在返回的数据中添加md5字段（用于校验除md5外其他数据是否变化），在下次请求的时候将这个md5作为参数传给后端，md5没有变化的情况下，不返回data，客户端可以直接使用上次请求缓存在本地的data。

md5.png
无用字段清理

每个版本的接口更新后，需要将无用字段进行清理。或者同个接口不同状态下需要返回的字段各不相同的时候，当次请求不需要的字段需要提醒后端不必下发，避免传输无用数据浪费用户流量。
图片裁剪服务

客户端上传图片后，当需要在列表这些图片区域较小的地方展示的时候，没必要直接加载原图，可以先在后端通过图片裁剪服务处理后再进行展示。例：
http://image-demo.img-cn-hangzhou.aliyuncs.com/example.jpg@100h_100w_1e_1c?spm=5176.doc32223.2.3.jmkKF9&file=example.jpg@100h_100w_1e_1c， 这是阿里云的图片裁剪服务，在url后面直接拼上裁剪参数，就可以实现将原图居中裁剪成100*100的缩略图。当需要展示高清图的时候，再加载原图的url。
局部刷新

一个页面，如果之前已经加载了20%的数据，那么就不需要每次都返回100%数据，只要返回剩余80%即可。例：订单列表页面，每个item已经具有类似orderId，orderDesc等字段，那么点击进入订单详情的时候，orderId，orderDesc就可以从订单列表传递过来即可，详情页的请求只需要返回订单相关的剩余数据，客户端需要额外处理数据组装逻辑，将前一个页面传递过来的字段和详情页请求到的字段组装成完整的model数据。
wifi与移动网络的区别对待

WiFi连接下，网络传输的电量消耗要比移动网络少很多，应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据。例：crash日志上报，数据统计接口等，可以在移动网络的情况下请求频率降低，或缓存，在wifi网络时上调请求频率，或将缓存的数据统一上报。还有上文提到的，如果是wifi网络状态下，就下发高清图提升用户体验，移动网络状态就下发缩略，或裁剪图。
八.体验优化

设计接口时，不能只考虑减少流量消耗，性能优化等，特定场景下用户体验的优化才是最高优先级的。
通过预加载降低对网络的依赖

使用APP的场景为网络较差的情况。例：配送员在使用配送APP的时候，商家地址如果在地下室，或配送员进入电梯的时候，这时候常要查看订单详情，网络信号又比较差的，就会影响正常工作。可以考虑在订单列表的接口中，将订单详情的数据一起请求下来，并通过md5判断详情页面数据是否变化，避免重复加载，这样其实用户在网络比较好的情况下请求一次列表后，再进入详情页，就不再需要重新请求，对网络的依赖也是最小的。同理，对于一些阅读类APP，前几页的文章，用户查看详情的概率较高，可以在返回文章列表的时候携带正文内容，则可以实现秒开详情，也可以判断网络状态，wifi场景下可以将详情数据都返回。
    {
         "md5"... // 校验所有item的detail，只有在新订单，或订单完成后移除的情况下，md5才会变化
         "orderList":[{
             "id"...
             "status"...
             "detail":{ // detail中尽量只保留变化情况较少的字段，避免md5频繁变化，如status就移出到item中存放
                 "type"...
                 "desc"...
             }
         },{
             "id"...
             "status"...
             "detail":{
                 "type"...
                 "desc"...
             }
         }]
    }



在移动互联网开发领域，我们经常需要针对移动设备，提供数据访问接口。在移动时代以前，接口设计并没有面对这么大的挑战，因为那时期的应用开发，前后端的区分并没有那么明显，需要专门设计接口的场景并不是很多。

然而，进入移动互联网时代，几乎所有的App数据访问，都是走的接口形式。而且，针对已经发布了安卓、iOS客户端版本的接口的重大修改，变得几乎不可能。于是，预先设计正确的、良好的接口，就显得格外重要。

让我们来看看如今，在业内被广泛采用的接口设计最佳原则。

API设计核心原则

它应该遵循Web标准
它应该对开发者友好
它在使用上应该保持简单、直观和一致性，不仅仅是容易使用，而应该让使用者感到愉悦
它应该是有效率的
采用RESTful URLs 和 actions 
如果说有一个实践，在世界范围内被广泛采用，那就是RESTful原则。RESTful这个原则是由Roy Fielding在他的学术论文network based software architectures的第五章里被第一次提到。

REST的核心思想是，把API按照逻辑上的资源来进行区分。这些资源被HTTP的不同方法( GET, POST, PUT, PATCH, DELETE )进行请求，每个方法代表不同的含义。

举个例子，如果我有一个对用户进行操作的接口。那么，针对这个用户的CRUD操作，采用RESTful的设计风格就是这个样子的，

GET /users - 获取用户列表 
GET /users/12 - 获取ID等于12的用户 
POST /users - 创建一个新用户 
PUT /users/12 - 更新ID等于12的用户 
PATCH /users/12 - 部分更新ID等于12的用户 
DELETE /users/12 - 删除ID等于12的用户

REST的伟大之处在于，采用了既有的HTTP methods，在一个单独的/users链接下，实现了多样的功能操作。你不需要遵循任何的命名规范，仅仅需要一个干净和整洁的URL结构 /users。

总是使用HTTPS

总是使用HTTPS，没有例外。当今，只要连接了互联网，你的API就能够在世界任何地方被访问。不是所有的访问都是安全的。有一些API数据没有被加密，很容易遭到劫持并被篡改。

撰写接口文档

好的文档，和好的接口同样重要。接口文档需要被很容易地找到和访问。大部分开发者会在进行接口开发之前，检查并查看接口文档。如果这些接口文档是写在PDF文档里，或者需要登录才能查看，那将不仅仅是难于查找，还不利于搜索。

接口文档应该描述完整的 Request/Response Cycle，并附上具体的例子。最好是，这些例子应该是真实可以访问的，比如把链接复制到浏览器里执行，或者用curl执行。GitHub 和 Stripe 的接口文档都写得很不错。

一旦你发布了一个API，那意味着，在没有通知调用者的情况下，你有责任不去破坏该接口的已有功能。如果你在今后修改该接口，需要及时更新接口文档，并且在发布接口的更新之前，及时通知你的接口调用者。

Versioning 
总是给你的API加上版本化。API版本化能够让你的API迭代地更快，防止老的请求访问你的API最新版。这样能够让你在进行API重大升级时，能够持续对老版本API进行一段时间的支持。

有很多的人在讨论，API的版本化，应该体现在URL上，还是在请求Header里。理论上讲，应该放在Header里。

API被发布出来，不会永远不变。变化是不可避免的。重要的是，我们怎么去管理这种变化。

限制API返回的字段 
API调用者有时候不希望资源的所有字段都返回。如果能够在调用时，选择API能够返回的字段，将减少网络传输流量，加速调用方的业务处理。

可以使用 fields 查询参数来限制API返回的字段。比如，以下请求只返回需要的字段信息： 
GET /users/12?fields=id,user_name,age 

错误代码 
就像HTML页面出错了展示的错误消息一样，API在出错时也应该提供一个有用的错误消息给调用方。

API应该总是返回合理的HTTP状态码。API的错误通常分为两类：客户端调用错误使用的400系列状态码，和服务端处理错误使用的500系列状态码。

一个JSON错误消息应该包含这么几个部分，一个有用的错误消息，一个唯一的错误码( 方便在接口文档里查到更详细的错误描述 )和一个详尽的错误描述。就像这样：


个人经验,不知是否有帮助. 对版本接口维护,个人认为是灾难性的.不同版本的业务逻辑,需要操作最新版本的数据结构.同时还要维护各版本的文档,各版本的自动化测试或者人工测试ok.

所以个人认为比较好的做法是.

在开始设计的时候, 查询类的接口,应尽可能使用被动式提供数据的无状态接口,格式应竟可能使用对象(不使用二维的集合).这样的接口对于扩展字段非常的方便,也很容易做到向下兼容. 操作类的接口,尽可能地将资源分离,比如修改用户信息,跟修改用户头像信息或者修改用户职位信息,这样的接口,尽可能使用独立的资源.

对于实在没有办法需要全面升级接口的. 如果可能,保持原有的业务,原有的接口运转正常. 然后构建一套全新的隔离的接口. 最后做下版本使用监控.当观察到所有用户都使用新版本的客户端的时候,并保持一段时间的时候.放弃对老版本的维护,继而下掉老版本的资源.当然,万不得已的时候,还可以用强制更新.




luax · #5 · 2015年9月06日
@wangping 不是的,我的意思是在设计的时候,规避这种情况.规避这种情况的方法有这么几种,

1.数据查询类的比较简单.比如一个商品接口,原先没有提供多图,后来需要提供多图的,简单的增加一个多图集合字段就可以.又比如商品需要增加优惠券信息,再增加优惠券的扩展字段就可以.

这样的增量接口,对于老的自动化测试来说,不会失效,仍然可以跑.这种都是比较简单的.

2 操作类的接口,尽可能的原子化,这样修改该一个功能的时候影响比较小.但是一般人都不太会犯这样的错误

3 比较难搞的是数据结构设计不合理. 其实用楼主的方案比较可取,那就是新增一个接口.只能说尽可能避免.

V2那种涉及大面积重构的. 建议是先保证原来的接口运转正常.然后监控客户端升级状态.
11562
hging · #6 · 2015年9月06日
之前我用过继承的方法来处理. 这样同样的代码不需要重复去写. 小bug就直接修掉, 真要有功能变更什么的. 加一个版本. 可以保证新老api都可以正常使用, 然后后期通过访问的api版本. 然后去考虑合并版本号.
2575
darkbaby123 · #7 · 2015年9月07日
如果逻辑基本没改，可以 v1 和 v2 都引用同一个 controller/action 的组合，这样只多加几条 routes 。我觉得最关键的还是保证修改代码不会导致老版本 API 行为发生改变或者挂掉。这点只能多加 request 测试，给每个 API response 校验 JSON schema 。
